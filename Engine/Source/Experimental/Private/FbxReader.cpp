#include "FbxReader.h"
#include "FbxUtility.h"
#include "fbxsdk\utils\fbxgeometryconverter.h"
#include "StaticMesh.h"
#include <iostream>
using std::cout;
using std::endl;


FBXReader::FBXReader()
	:FBXSdkManager(nullptr)
	, MainScene(nullptr)
{

}

FBXReader::~FBXReader()
{
	if (FBXSdkManager)
	{
		FBXSdkManager->Destroy();
	}
}

void FBXReader::InitialFBXSDK()
{
	// Create the FBX SDK memory manager object.
	// The SDK Manager allocates and frees memory
	// for almost all the classes in the SDK.
	FBXSdkManager = FbxManager::Create();

	// create an IOSettings object
	FbxIOSettings * Ios = FbxIOSettings::Create(FBXSdkManager, IOSROOT);
	FBXSdkManager->SetIOSettings(Ios);
}

bool FBXReader::ImportFile(FString FileName)
{
	//cout << "[FBXReader::ImportFile]:FileName: " << FileName << endl;
	// Create an importer.
	FbxImporter* Importer = FbxImporter::Create(FBXSdkManager, "");

	// Initialize the importer by providing a filename.
	const bool ImportStatus = Importer->Initialize(TCHAR_TO_ANSI(*FileName), -1, FBXSdkManager->GetIOSettings());

	// Get the version number of the FBX file format.
	int FileMajor, FileMinor, FileRevision;
	Importer->GetFileVersion(FileMajor, FileMinor, FileRevision);
	cout << "[FBXReader::ImportFile]:FileMajor" << FileMajor << ",FileMinor " << FileMinor << ", FileRevision " << FileRevision << endl;

	if (!ImportStatus)  // Problem with the file to be imported
	{
		FbxString error = Importer->GetStatus().GetErrorString();
		cout << "Call to FbxImporter::Initialize() failed." << endl;
		cout << "Error returned:" << error.Buffer() << endl;

		if (Importer->GetStatus().GetCode() == FbxStatus::eInvalidFileVersion)
		{
			// Get the version number of the FBX files generated by the
			// version of FBX SDK that you are using.
			int lSDKMajor, lSDKMinor, lSDKRevision;
			FbxManager::GetFileFormatVersion(lSDKMajor, lSDKMinor, lSDKRevision);
			cout << "[FBXReader::ImportFile]:lSDKMajor" << lSDKMajor << ",lSDKMinor " << lSDKMinor << ", lSDKRevision " << lSDKRevision << endl;
			cout << "[FBXReader::ImportFile]:FileMajor" << FileMajor << ",FileMinor " << FileMinor << ", FileRevision " << FileRevision << endl;
		}
		return false;

	}
	// Create a scene
	FbxIOSettings * Ios = FBXSdkManager->GetIOSettings();
	Ios->SetBoolProp(IMP_FBX_MATERIAL, true);
	Ios->SetBoolProp(IMP_FBX_TEXTURE, true);
	Ios->SetBoolProp(IMP_FBX_LINK, true);
	Ios->SetBoolProp(IMP_FBX_SHAPE, true);
	Ios->SetBoolProp(IMP_FBX_GOBO, true);
	Ios->SetBoolProp(IMP_FBX_ANIMATION, true);
	Ios->SetBoolProp(IMP_SKINS, true);
	Ios->SetBoolProp(IMP_DEFORMATION, true);
	Ios->SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
	Ios->SetBoolProp(IMP_TAKE, true);

	// Import the scene.
	MainScene = FbxScene::Create(FBXSdkManager, "");
	bool bSuccessLoadScene = Importer->Import(MainScene);
	Importer->Destroy();
	return bSuccessLoadScene;
}

std::unique_ptr<MeshModel> FBXReader::GenerateModelMesh()
{
	ConvertScene();
	
	pMeshModel = new MeshModel();
	pMeshModel->RootNode = MainScene->GetRootNode();
	pMeshModel->Scene = MainScene;
	auto Result =LoadNodes();
	if (Result.first)
	{
		return std::unique_ptr<MeshModel>(pMeshModel);
	}
	else
	{
		delete pMeshModel;
		return std::unique_ptr<MeshModel>(nullptr);
	}
}

void FBXReader::ConvertScene()
{
	FbxAxisSystem SceneAxisSystem = MainScene->GetGlobalSettings().GetAxisSystem();
	//FbxAxisSystem OurAxisSystem(FbxAxisSystem::eYAxis, FbxAxisSystem::eParityOdd, FbxAxisSystem::eRightHanded);
	//if (SceneAxisSystem != OurAxisSystem)
	//{
	//	OurAxisSystem.ConvertScene(MainScene);
	//}

	if (SceneAxisSystem != FbxAxisSystem::eMax)
	{
		FbxAxisSystem::Max.ConvertScene(MainScene);
	}
	// Convert Unit System to what is used in this example, if needed
	FbxSystemUnit SceneSystemUnit = MainScene->GetGlobalSettings().GetSystemUnit();
	if (SceneSystemUnit != FbxSystemUnit::cm)
	{
		//The unit in this example is centimeter.
		FbxSystemUnit::cm.ConvertScene(MainScene);
	}

	// Convert mesh, NURBS and patch into triangle mesh
	FbxGeometryConverter lGeomConverter(FBXSdkManager);
	lGeomConverter.Triangulate(MainScene, /*replace*/true);
}

std::pair<bool,std::string> FBXReader::LoadNodes()
{
	MainScene->FillAnimStackNameArray(pMeshModel->mAnimStackNameArray);
	// Get the list of all the animation stack.
	auto Result = LoadNodesRecursive(MainScene->GetRootNode());
	BuildSkeletonRelationship();
	return Result;
}

std::pair<bool,std::string> FBXReader::LoadNodesRecursive(FbxNode* pNode)
{
	FbxNodeAttribute* NodeAttribute = pNode->GetNodeAttribute();
	bool IsSuccess= true;
	std::string ErrorMsg;
	if (NodeAttribute && NodeAttribute->GetAttributeType() == FbxNodeAttribute::eMesh)
	{
		FbxMesh * lMesh = pNode->GetMesh();
		TUniquePtr<StaticMesh> pStaticMesh = MakeUnique<StaticMesh>();
		auto Result = LoadMeshInfo(lMesh, pStaticMesh.Get());
		if (!Result.first)
		{
			IsSuccess = false;
			return std::make_pair<>(false, Result.second);
		}
			
		pMeshModel->MeshArrays.Add(MoveTemp(pStaticMesh));
		pMeshModel->mapFbxNodeToStaticMesh.Add(pNode, pMeshModel->MeshArrays.Num() - 1);
	}
	else if (NodeAttribute && NodeAttribute->GetAttributeType() == FbxNodeAttribute::eSkeleton)
	{
		FbxSkeleton *pSkeleton = pNode->GetSkeleton();
		auto Result = LoadSkeletonInfo(pSkeleton);
		if (!Result.first)
		{
			IsSuccess = false;
			return Result;
		}
	}
	const int ChildCount = pNode->GetChildCount();
	for (int ChildIndex = 0; ChildIndex < ChildCount; ++ChildIndex)
	{
		auto Result = LoadNodesRecursive(pNode->GetChild(ChildIndex));
		if (!Result.first)
		{
			IsSuccess = false;
			return Result;
		}
	}
	return std::make_pair<>(IsSuccess, "");
}

std::pair<bool,std::string> FBXReader::LoadMeshInfo(FbxMesh *pMesh, StaticMesh* pStaticMesh)
{
	pStaticMesh->Clear();

	pStaticMesh->MeshName = pMesh->GetNode()->GetName();
	const int PolygonCount = pMesh->GetPolygonCount();
	pStaticMesh->FaceNum = PolygonCount;
	const int PolygonVertexCount = pMesh->GetControlPointsCount();
	FbxVector4* pControlPointsArray = pMesh->GetControlPoints();

	XMFLOAT3 vertex[3];
	XMFLOAT4 color[3];
	XMFLOAT3 normal[3];
	XMFLOAT3 tangent[3];
	XMFLOAT2 uv[3][2];
	int      index[3];
	TArray<LocalVertex> LocalVertexBuffer;
	TArray<int>  LocalIndexBuffer;
	int VertexCount = 0;
	TArray<XMFLOAT3>  ControlPoints;
	int ControlPointCounts = pMesh->GetControlPointsCount();
	for(int i=0;i<ControlPointCounts;++i)
	{
		FbxVector4 VertexPos = pMesh->GetControlPointAt(i);
		ControlPoints.Emplace(XMFLOAT3(VertexPos[0],VertexPos[1],VertexPos[2]));
	}



	for (int TriangleIndex = 0; TriangleIndex < PolygonCount; ++TriangleIndex)
	{
		for (int i = 0; i < 3; ++i)
		{
			int CtrlPointIndex = pMesh->GetPolygonVertex(TriangleIndex, i);
			ReadVertex(pControlPointsArray, CtrlPointIndex, &vertex[i]);
			ReadColor(pMesh, CtrlPointIndex, VertexCount, color);
			ReadUV(pMesh, CtrlPointIndex, pMesh->GetTextureUVIndex(TriangleIndex, i), 0, &uv[i][0]);
			ReadNormal(pMesh, CtrlPointIndex, VertexCount, &normal[i]);
			ReadTangent(pMesh, CtrlPointIndex, VertexCount, &tangent[i]);
			index[i] = VertexCount++;
			LocalVertex tmpLocalVertex;
			tmpLocalVertex.Position = FVector(vertex[i].x, vertex[i].y, vertex[i].z);
			tmpLocalVertex.Normal = FVector(normal[i].x, normal[i].y, normal[i].z);
			tmpLocalVertex.UV0 = FVector2D(uv[i][0].x, uv[i][0].y);
			LocalVertexBuffer.Emplace(tmpLocalVertex);
		}
		for (int i = 0; i < 3; ++i)
		{
			LocalIndexBuffer.Add(index[i]);
		}
	}
	ConnectMaterialToMesh(pMesh, pStaticMesh);
	pStaticMesh->VertexArray = MoveTemp(LocalVertexBuffer);
	pStaticMesh->IndexArray = MoveTemp(LocalIndexBuffer);
	pStaticMesh->m_pNode = pMesh->GetNode();
	
	FbxAMatrix& FbxWorldMatrix =  pMesh->GetNode()->EvaluateGlobalTransform();
	pStaticMesh->MatWorld = FbxMatrixToFMATRIX(FbxWorldMatrix);
	return std::make_pair<>(true, "");
}

std::pair<bool, std::string> FBXReader::LoadSkeletonInfo(FbxSkeleton* pSkeleton)
{
	FbxString BoneName = pSkeleton->GetName();
	FbxString BoneNodeName = pSkeleton->GetNode()->GetName();
	auto Result = pMeshModel->MainSkeleton.AddBone(pSkeleton->GetNode()->GetName());
	if (!Result.first)
	{
		return std::make_pair<>(false, "find two same bone names");
	}
	Bone & NewBone = pMeshModel->MainSkeleton.GetBone(Result.second);
	FbxAMatrix BoneInitPos = pSkeleton->GetNode()->EvaluateGlobalTransform();
	FbxAMatrix lGeometryOffset = GetGeometry(pSkeleton->GetNode());
	NewBone.MatLocalTransform = FbxMatrixToXMMATRIX(lGeometryOffset*BoneInitPos);
	return std::make_pair<>(true, "");
}

void  FBXReader::ReadVertex(FbxVector4* pControlPointsArray, int CtrlPointIndex, XMFLOAT3* pVertex)
{
	pVertex->x = pControlPointsArray[CtrlPointIndex][0];
	pVertex->y = pControlPointsArray[CtrlPointIndex][1];
	pVertex->z = pControlPointsArray[CtrlPointIndex][2];
}
void FBXReader::ReadColor(FbxMesh* pMesh, int CtrlPointIndex, int vertexCounter, XMFLOAT4* pColor)
{
	if (pMesh->GetElementVertexColorCount() < 1)
	{
		return;
	}

	FbxGeometryElementVertexColor* pVertexColor = pMesh->GetElementVertexColor(0);
	switch (pVertexColor->GetMappingMode())
	{
	case FbxGeometryElement::eByControlPoint:
	{
		switch (pVertexColor->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pColor->x = pVertexColor->GetDirectArray().GetAt(CtrlPointIndex).mRed;
			pColor->y = pVertexColor->GetDirectArray().GetAt(CtrlPointIndex).mGreen;
			pColor->z = pVertexColor->GetDirectArray().GetAt(CtrlPointIndex).mBlue;
			pColor->w = pVertexColor->GetDirectArray().GetAt(CtrlPointIndex).mAlpha;
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = pVertexColor->GetIndexArray().GetAt(CtrlPointIndex);
			pColor->x = pVertexColor->GetDirectArray().GetAt(id).mRed;
			pColor->y = pVertexColor->GetDirectArray().GetAt(id).mGreen;
			pColor->z = pVertexColor->GetDirectArray().GetAt(id).mBlue;
			pColor->w = pVertexColor->GetDirectArray().GetAt(id).mAlpha;
		}
		break;

		default:
			break;
		}
	}
	break;

	case FbxGeometryElement::eByPolygonVertex:
	{
		switch (pVertexColor->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pColor->x = pVertexColor->GetDirectArray().GetAt(vertexCounter).mRed;
			pColor->y = pVertexColor->GetDirectArray().GetAt(vertexCounter).mGreen;
			pColor->z = pVertexColor->GetDirectArray().GetAt(vertexCounter).mBlue;
			pColor->w = pVertexColor->GetDirectArray().GetAt(vertexCounter).mAlpha;
		}
		break;
		case FbxGeometryElement::eIndexToDirect:
		{
			int id = pVertexColor->GetIndexArray().GetAt(vertexCounter);
			pColor->x = pVertexColor->GetDirectArray().GetAt(id).mRed;
			pColor->y = pVertexColor->GetDirectArray().GetAt(id).mGreen;
			pColor->z = pVertexColor->GetDirectArray().GetAt(id).mBlue;
			pColor->w = pVertexColor->GetDirectArray().GetAt(id).mAlpha;
		}
		break;
		default:
			break;
		}
	}
	break;
	}
}


void FBXReader::ReadUV(FbxMesh* pMesh, int CtrlPointIndex, int TextureUVIndex, int UVLayer, XMFLOAT2* pUV)
{
	if (UVLayer >= 2 || pMesh->GetElementUVCount() <= UVLayer)
	{
		return;
	}

	FbxGeometryElementUV* pVertexUV = pMesh->GetElementUV(UVLayer);

	switch (pVertexUV->GetMappingMode())
	{
	case FbxGeometryElement::eByControlPoint:
	{
		switch (pVertexUV->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pUV->x = pVertexUV->GetDirectArray().GetAt(CtrlPointIndex).mData[0];
			pUV->y = pVertexUV->GetDirectArray().GetAt(CtrlPointIndex).mData[1];
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = pVertexUV->GetIndexArray().GetAt(CtrlPointIndex);
			pUV->x = pVertexUV->GetDirectArray().GetAt(id).mData[0];
			pUV->y = pVertexUV->GetDirectArray().GetAt(id).mData[1];
		}
		break;

		default:
			break;
		}
	}
	break;

	case FbxGeometryElement::eByPolygonVertex:
	{
		switch (pVertexUV->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pUV->x = pVertexUV->GetDirectArray().GetAt(TextureUVIndex).mData[0];
			pUV->y = pVertexUV->GetDirectArray().GetAt(TextureUVIndex).mData[1];
		}
		case FbxGeometryElement::eIndexToDirect:
		{
			int id = pVertexUV->GetIndexArray().GetAt(TextureUVIndex);
			pUV->x = pVertexUV->GetDirectArray().GetAt(id).mData[0];
			pUV->y = pVertexUV->GetDirectArray().GetAt(id).mData[1];
		}
		break;

		default:
			break;
		}
	}
	break;
	}
}

void FBXReader::ReadNormal(FbxMesh* pMesh, int CtrlPointIndex, int VertexCounter, XMFLOAT3* pNormal)
{
	if (pMesh->GetElementNormalCount() < 1)
	{
		return;
	}

	FbxGeometryElementNormal* leNormal = pMesh->GetElementNormal(0);
	switch (leNormal->GetMappingMode())
	{
	case FbxGeometryElement::eByControlPoint:
	{
		switch (leNormal->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pNormal->x = leNormal->GetDirectArray().GetAt(CtrlPointIndex).mData[0];
			pNormal->y = leNormal->GetDirectArray().GetAt(CtrlPointIndex).mData[1];
			pNormal->z = leNormal->GetDirectArray().GetAt(CtrlPointIndex).mData[2];
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = leNormal->GetIndexArray().GetAt(CtrlPointIndex);
			pNormal->x = leNormal->GetDirectArray().GetAt(id).mData[0];
			pNormal->y = leNormal->GetDirectArray().GetAt(id).mData[1];
			pNormal->z = leNormal->GetDirectArray().GetAt(id).mData[2];
		}
		break;

		default:
			break;
		}
	}
	break;

	case FbxGeometryElement::eByPolygonVertex:
	{
		switch (leNormal->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pNormal->x = leNormal->GetDirectArray().GetAt(VertexCounter).mData[0];
			pNormal->y = leNormal->GetDirectArray().GetAt(VertexCounter).mData[1];
			pNormal->z = leNormal->GetDirectArray().GetAt(VertexCounter).mData[2];
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = leNormal->GetIndexArray().GetAt(VertexCounter);
			pNormal->x = leNormal->GetDirectArray().GetAt(id).mData[0];
			pNormal->y = leNormal->GetDirectArray().GetAt(id).mData[1];
			pNormal->z = leNormal->GetDirectArray().GetAt(id).mData[2];
		}
		break;

		default:
			break;
		}
	}
	break;
	}
}

void FBXReader::ReadTangent(FbxMesh* pMesh, int CtrlPointIndex, int VertexCounter, XMFLOAT3* pTangent)
{
	if (pMesh->GetElementTangentCount() < 1)
	{
		return;
	}

	FbxGeometryElementTangent* Tangent = pMesh->GetElementTangent(0);
	switch (Tangent->GetMappingMode())
	{
	case FbxGeometryElement::eByControlPoint:
	{
		switch (Tangent->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pTangent->x = Tangent->GetDirectArray().GetAt(CtrlPointIndex).mData[0];
			pTangent->y = Tangent->GetDirectArray().GetAt(CtrlPointIndex).mData[1];
			pTangent->z = Tangent->GetDirectArray().GetAt(CtrlPointIndex).mData[2];
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = Tangent->GetIndexArray().GetAt(CtrlPointIndex);
			pTangent->x = Tangent->GetDirectArray().GetAt(id).mData[0];
			pTangent->y = Tangent->GetDirectArray().GetAt(id).mData[1];
			pTangent->z = Tangent->GetDirectArray().GetAt(id).mData[2];
		}
		break;

		default:
			break;
		}
	}
	break;

	case FbxGeometryElement::eByPolygonVertex:
	{
		switch (Tangent->GetReferenceMode())
		{
		case FbxGeometryElement::eDirect:
		{
			pTangent->x = Tangent->GetDirectArray().GetAt(VertexCounter).mData[0];
			pTangent->y = Tangent->GetDirectArray().GetAt(VertexCounter).mData[1];
			pTangent->z = Tangent->GetDirectArray().GetAt(VertexCounter).mData[2];
		}
		break;

		case FbxGeometryElement::eIndexToDirect:
		{
			int id = Tangent->GetIndexArray().GetAt(VertexCounter);
			pTangent->x = Tangent->GetDirectArray().GetAt(id).mData[0];
			pTangent->y = Tangent->GetDirectArray().GetAt(id).mData[1];
			pTangent->z = Tangent->GetDirectArray().GetAt(id).mData[2];
		}
		break;

		default:
			break;
		}
	}
	break;
	}
}
void FBXReader::ConnectMaterialToMesh(FbxMesh* pMesh, StaticMesh* pStaticMesh)
{
	// Get the material index list of current mesh  
	if (pMesh->GetElementMaterial())
	{
		FbxLayerElementArrayTemplate<int>* pMaterialIndices= &pMesh->GetElementMaterial()->GetIndexArray();
		FbxGeometryElement::EMappingMode  materialMappingMode = pMesh->GetElementMaterial()->GetMappingMode();
		if (pMaterialIndices)
		{
			switch (materialMappingMode)
			{
			case FbxGeometryElement::eByPolygon:
			{
				if (pMaterialIndices->GetCount() == pStaticMesh->FaceNum)
				{
					pStaticMesh->MapTriangleIndexToMaterialIndex.SetNum(pStaticMesh->FaceNum);
					for (int triangleIndex = 0; triangleIndex < pStaticMesh->FaceNum; ++triangleIndex)
					{
						int materialIndex = pMaterialIndices->GetAt(triangleIndex);

						pStaticMesh->MapTriangleIndexToMaterialIndex[triangleIndex] = materialIndex;
					}
				}
			}
			break;

			case FbxGeometryElement::eAllSame:
			{
				int lMaterialIndex = pMaterialIndices->GetAt(0);
				pStaticMesh->MapTriangleIndexToMaterialIndex.SetNum(pStaticMesh->FaceNum);
				for (int triangleIndex = 0; triangleIndex < pStaticMesh->FaceNum; ++triangleIndex)
				{
					int materialIndex = pMaterialIndices->GetAt(triangleIndex);
					pStaticMesh->MapTriangleIndexToMaterialIndex[triangleIndex] = materialIndex;
				}
			}
			}
		}
	}

	ReadMaterial(pMesh, pStaticMesh);
}
void FBXReader::ReadMaterial(FbxMesh* pMesh, StaticMesh* pStaticMesh)
{
	int materialCount;

	if (pMesh && pMesh->GetNode())
	{
		FbxNode* pNode = pMesh->GetNode();
		materialCount = pNode->GetMaterialCount();
		if (materialCount > 0)
		{
			for (int materialIndex = 0; materialIndex < materialCount; materialIndex++)
			{
				FbxSurfaceMaterial* pSurfaceMaterial = pNode->GetMaterial(materialIndex);
				pStaticMesh->MaterialArray.Emplace(LoadMaterialAttribute(pSurfaceMaterial));
			}
		}
	}
}
MaterialBaseFbx FBXReader::LoadMaterialAttribute(FbxSurfaceMaterial* pSurfaceMaterial)
{
	MaterialBaseFbx OutMaterial;
	// Get the name of material  
	OutMaterial.MaterialName = pSurfaceMaterial->GetName();

	// Phong material  
	if (pSurfaceMaterial->GetClassId().Is(FbxSurfacePhong::ClassId))
	{
		// Ambient Color  
		FbxDouble3 AmbientColor = ((FbxSurfacePhong*)pSurfaceMaterial)->Ambient;
		// ...  

		// Diffuse Color  
		FbxDouble3 DiffuseColor = ((FbxSurfacePhong*)pSurfaceMaterial)->Diffuse;
		// ...  
		const FbxProperty DiffuseProperty = pSurfaceMaterial->FindProperty(FbxSurfaceMaterial::sDiffuse);
		if(DiffuseProperty.IsValid())
		{
			const int TextureCount = DiffuseProperty.GetSrcObjectCount<FbxFileTexture>();
			if (TextureCount)
			{
				const FbxFileTexture* Texture = DiffuseProperty.GetSrcObject<FbxFileTexture>();
				if (Texture)
				{
					OutMaterial.DiffusePath = Texture->GetFileName();
				}
			}
		}
		// Specular Color  
		FbxDouble3 SpecularColor = ((FbxSurfacePhong*)pSurfaceMaterial)->Specular;
		// ...  

		// Emissive Color  
		FbxDouble3 EmissiveColor = ((FbxSurfacePhong*)pSurfaceMaterial)->Emissive;
		// ...  

		// Opacity  
		FbxDouble Opacity = ((FbxSurfacePhong*)pSurfaceMaterial)->TransparencyFactor;
		// ...  

		// Shininess  
		FbxDouble Shininess = ((FbxSurfacePhong*)pSurfaceMaterial)->Shininess;
		// ...  

		// Reflectivity  
		FbxDouble Reflectivity = ((FbxSurfacePhong*)pSurfaceMaterial)->ReflectionFactor;
		// ...  
	}

	// Lambert material  
	if (pSurfaceMaterial->GetClassId().Is(FbxSurfaceLambert::ClassId))
	{

		// Ambient Color  
		FbxDouble3 Ambient = ((FbxSurfaceLambert*)pSurfaceMaterial)->Ambient;
		// ...  

		// Diffuse Color  
		FbxDouble3 Diffuse = ((FbxSurfaceLambert*)pSurfaceMaterial)->Diffuse;
		// ...  
		const FbxProperty DiffuseProperty = pSurfaceMaterial->FindProperty(FbxSurfaceMaterial::sDiffuse);
		if (DiffuseProperty.IsValid())
		{
			const int TextureCount = DiffuseProperty.GetSrcObjectCount<FbxFileTexture>();
			if (TextureCount)
			{
				const FbxFileTexture* Texture = DiffuseProperty.GetSrcObject<FbxFileTexture>();
				if (Texture)
				{
					OutMaterial.DiffusePath = Texture->GetFileName();
				}
			}
		}
		// Emissive Color  
		FbxDouble3 Emissive = ((FbxSurfaceLambert*)pSurfaceMaterial)->Emissive;
		// ...  

		// Opacity  
		FbxDouble Opacity = ((FbxSurfaceLambert*)pSurfaceMaterial)->TransparencyFactor;
		// ...  
	}

	return OutMaterial;
}

void FBXReader::BuildSkeletonRelationship()
{
	BuildSkeletonRecursive(MainScene->GetRootNode());
	
}

void FBXReader::BuildSkeletonRecursive(FbxNode * pNode)
{
	FbxNodeAttribute* NodeAttribute = pNode->GetNodeAttribute();
	bool IsSuccess = true;
	std::string ErrorMsg;
	if (NodeAttribute && NodeAttribute->GetAttributeType() == FbxNodeAttribute::eSkeleton)
	{
		FbxSkeleton *pSkeleton = pNode->GetSkeleton();
		if (pSkeleton->GetSkeletonType() == FbxSkeleton::eRoot || pSkeleton->GetSkeletonType() == FbxSkeleton::eLimb || pSkeleton->GetSkeletonType() == FbxSkeleton::eLimbNode)
		{
			FbxSkeleton* pParentSkeleton= GetParentSkeleton(pSkeleton);
			if (!pParentSkeleton)
			{
				//¸ù¹Ç÷À
				Bone *pCurrentBone = pMeshModel->MainSkeleton.GetBone(pSkeleton->GetNode()->GetName());
				assert(pCurrentBone);
				assert(pMeshModel->MainSkeleton.RootBone == Bone::InvalidBone);
				pCurrentBone->ParentBoneID = Bone::InvalidBone;
				pCurrentBone->MatParentToBone = pCurrentBone->MatLocalTransform;
				pMeshModel->MainSkeleton.RootBone = pCurrentBone->BoneID;
				
			}
			else
			{
				Bone* pParentBone = pMeshModel->MainSkeleton.GetBone(pParentSkeleton->GetNode()->GetName());
				assert(pParentBone);
				Bone* pCurrentBone = pMeshModel->MainSkeleton.GetBone(pSkeleton->GetNode()->GetName());
				assert(pCurrentBone);
				pParentBone->ChildBones.emplace_back(pCurrentBone->BoneID);
				pCurrentBone->ParentBoneID = pParentBone->BoneID;
				auto LocalTrans = pSkeleton->GetNode()->EvaluateLocalTransform();
				XMVECTOR Determain;
				pCurrentBone->MatParentToBone = DirectX::XMMatrixInverse(&Determain, pParentBone->MatLocalTransform)*pCurrentBone->MatLocalTransform;
			}
		}
	}

	for (int i = 0; i < pNode->GetChildCount(); ++i)
	{
		FbxNode* pChildNode = pNode->GetChild(i);
		BuildSkeletonRecursive(pChildNode);
	}
}

FbxSkeleton* FBXReader::GetParentSkeleton(FbxSkeleton* pSkeleton)
{
	FbxNode *pNode = pSkeleton->GetNode();
	FbxNode *ParentNode = pNode->GetParent();
	while (ParentNode)
	{
		FbxNodeAttribute* NodeAttribute = ParentNode->GetNodeAttribute();
		if (NodeAttribute && NodeAttribute->GetAttributeType() == FbxNodeAttribute::eSkeleton)
		{
			FbxSkeleton *pSkeleton = ParentNode->GetSkeleton();
			if (pSkeleton->GetSkeletonType() == FbxSkeleton::eRoot || pSkeleton->GetSkeletonType() == FbxSkeleton::eLimb || pSkeleton->GetSkeletonType() == FbxSkeleton::eLimbNode)
			{
				return pSkeleton;
			}
		}
		ParentNode = ParentNode->GetParent();
	}
	return nullptr;
}

