// Copyright 1998-2017 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "GeneratedCppIncludes.h"
#include "CoreUObject.generated.dep.h"
PRAGMA_DISABLE_OPTIMIZATION
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCode1CoreUObject() {}
FName COREUOBJECT_ExecuteUbergraph = FName(TEXT("ExecuteUbergraph"));
static class UEnum* ERangeBoundTypes_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ERangeBoundTypes();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_ERangeBoundTypes, Z_Construct_UPackage__Script_CoreUObject(), TEXT("ERangeBoundTypes"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ERangeBoundTypes(ERangeBoundTypes_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("ERangeBoundTypes"), false, nullptr, nullptr);
static class UEnum* EUnit_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EUnit();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_EUnit, Z_Construct_UPackage__Script_CoreUObject(), TEXT("EUnit"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EUnit(EUnit_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("EUnit"), false, nullptr, nullptr);
static class UEnum* EMouseCursor_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EMouseCursor();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_EMouseCursor, Z_Construct_UPackage__Script_CoreUObject(), TEXT("EMouseCursor"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EMouseCursor(EMouseCursor_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("EMouseCursor"), false, nullptr, nullptr);
static class UEnum* EPixelFormat_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EPixelFormat();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_EPixelFormat, Z_Construct_UPackage__Script_CoreUObject(), TEXT("EPixelFormat"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EPixelFormat(EPixelFormat_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("EPixelFormat"), false, nullptr, nullptr);
static class UEnum* EInterpCurveMode_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EInterpCurveMode();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_EInterpCurveMode, Z_Construct_UPackage__Script_CoreUObject(), TEXT("EInterpCurveMode"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EInterpCurveMode(EInterpCurveMode_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("EInterpCurveMode"), false, nullptr, nullptr);
static class UEnum* EAxis_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EAxis();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_EAxis, Z_Construct_UPackage__Script_CoreUObject(), TEXT("EAxis"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EAxis(EAxis_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("EAxis"), false, nullptr, nullptr);
static class UEnum* ELogTimes_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ELogTimes();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_ELogTimes, Z_Construct_UPackage__Script_CoreUObject(), TEXT("ELogTimes"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELogTimes(ELogTimes_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("ELogTimes"), false, nullptr, nullptr);
static class UEnum* ESearchDir_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchDir();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_ESearchDir, Z_Construct_UPackage__Script_CoreUObject(), TEXT("ESearchDir"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESearchDir(ESearchDir_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("ESearchDir"), false, nullptr, nullptr);
static class UEnum* ESearchCase_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchCase();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_ESearchCase, Z_Construct_UPackage__Script_CoreUObject(), TEXT("ESearchCase"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ESearchCase(ESearchCase_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("ESearchCase"), false, nullptr, nullptr);
	IMPLEMENT_CLASS(UObject, 1045520044);
static class UEnum* ELifetimeCondition_StaticEnum()
{
	extern COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ELifetimeCondition();
		Singleton = GetStaticEnum(Z_Construct_UEnum_CoreUObject_ELifetimeCondition, Z_Construct_UPackage__Script_CoreUObject(), TEXT("ELifetimeCondition"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_ELifetimeCondition(ELifetimeCondition_StaticEnum, TEXT("/Script/CoreUObject"), TEXT("ELifetimeCondition"), false, nullptr, nullptr);
#if USE_COMPILED_IN_NATIVES
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ERangeBoundTypes();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EUnit();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EMouseCursor();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EPixelFormat();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EInterpCurveMode();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_EAxis();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ELogTimes();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchDir();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ESearchCase();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInt32Interval();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatInterval();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInt32Range();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInt32RangeBound();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatRange();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFloatRangeBound();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FFallbackStruct();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FStringClassReference();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FStringAssetReference();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTimespan();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FDateTime();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRandomStream();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveTwoVectors();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveQuat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointQuat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveFloat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointFloat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FMatrix();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FOrientedBox();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBoxSphereBounds();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBox2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FBox();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FIntVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FIntPoint();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPackedRGBA16N();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPackedRGB10A2N();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPackedNormal();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FQuat();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FPlane();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTwoVectors();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2D();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector4();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FGuid();
	COREUOBJECT_API class UFunction* Z_Construct_UFunction_UObject_ExecuteUbergraph();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	COREUOBJECT_API class UEnum* Z_Construct_UEnum_CoreUObject_ELifetimeCondition();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FUniqueNetIdWrapper();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FJoinabilitySettings();
	COREUOBJECT_API class UPackage* Z_Construct_UPackage__Script_CoreUObject();
	UEnum* Z_Construct_UEnum_CoreUObject_ERangeBoundTypes()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_ERangeBoundTypes_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ERangeBoundTypes"), 0, Get_Z_Construct_UEnum_CoreUObject_ERangeBoundTypes_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ERangeBoundTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ERangeBoundTypes::Exclusive")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ERangeBoundTypes::Inclusive")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ERangeBoundTypes::Open")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ERangeBoundTypes::ERangeBoundTypes_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("ERangeBoundTypes::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("Exclusive.ToolTip"), TEXT("The range excludes the bound."));
			MetaData->SetValue(ReturnEnum, TEXT("Inclusive.ToolTip"), TEXT("The range includes the bound."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Open.ToolTip"), TEXT("The bound is open."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enumerates the valid types of range bounds."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_ERangeBoundTypes_CRC() { return 2518268341U; }
	UEnum* Z_Construct_UEnum_CoreUObject_EUnit()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_EUnit_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EUnit"), 0, Get_Z_Construct_UEnum_CoreUObject_EUnit_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EUnit"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Micrometers")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Millimeters")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Centimeters")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Meters")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Kilometers")), 4));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Inches")), 5));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Feet")), 6));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Yards")), 7));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Miles")), 8));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Lightyears")), 9));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Degrees")), 10));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Radians")), 11));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::MetersPerSecond")), 12));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::KilometersPerHour")), 13));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::MilesPerHour")), 14));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Celsius")), 15));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Farenheit")), 16));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Kelvin")), 17));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Micrograms")), 18));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Milligrams")), 19));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Grams")), 20));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Kilograms")), 21));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::MetricTons")), 22));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Ounces")), 23));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Pounds")), 24));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Stones")), 25));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Newtons")), 26));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::PoundsForce")), 27));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::KilogramsForce")), 28));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Hertz")), 29));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Kilohertz")), 30));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Megahertz")), 31));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Gigahertz")), 32));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::RevolutionsPerMinute")), 33));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Bytes")), 34));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Kilobytes")), 35));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Megabytes")), 36));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Gigabytes")), 37));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Terabytes")), 38));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Lumens")), 39));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Milliseconds")), 40));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Seconds")), 41));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Minutes")), 42));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Hours")), 43));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Days")), 44));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Months")), 45));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Years")), 46));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Multiplier")), 47));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::Unspecified")), 48));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EUnit::EUnit_MAX")), 49));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::EnumClass);
			ReturnEnum->CppType = TEXT("EUnit");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("Bytes.ToolTip"), TEXT("Data Size units"));
			MetaData->SetValue(ReturnEnum, TEXT("Celsius.ToolTip"), TEXT("Temperature units"));
			MetaData->SetValue(ReturnEnum, TEXT("Degrees.ToolTip"), TEXT("Angular units"));
			MetaData->SetValue(ReturnEnum, TEXT("Hertz.ToolTip"), TEXT("Frequency units"));
			MetaData->SetValue(ReturnEnum, TEXT("Lumens.ToolTip"), TEXT("Luminous flux units"));
			MetaData->SetValue(ReturnEnum, TEXT("MetersPerSecond.ToolTip"), TEXT("Speed units"));
			MetaData->SetValue(ReturnEnum, TEXT("Micrograms.ToolTip"), TEXT("Mass units"));
			MetaData->SetValue(ReturnEnum, TEXT("Micrometers.ToolTip"), TEXT("Scalar distance/length unit."));
			MetaData->SetValue(ReturnEnum, TEXT("Milliseconds.ToolTip"), TEXT("Time units"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Multiplier.ToolTip"), TEXT("Arbitrary multiplier"));
			MetaData->SetValue(ReturnEnum, TEXT("Newtons.ToolTip"), TEXT("Force units"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("A set of numerical unit types supported by the engine. Mirrored from UnitConversion.h"));
			MetaData->SetValue(ReturnEnum, TEXT("Unspecified.ToolTip"), TEXT("Symbolic entry, not specifiable on meta data."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_EUnit_CRC() { return 3841282393U; }
	UEnum* Z_Construct_UEnum_CoreUObject_EMouseCursor()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_EMouseCursor_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EMouseCursor"), 0, Get_Z_Construct_UEnum_CoreUObject_EMouseCursor_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EMouseCursor"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::None")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::Default")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::TextEditBeam")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::ResizeLeftRight")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::ResizeUpDown")), 4));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::ResizeSouthEast")), 5));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::ResizeSouthWest")), 6));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::CardinalCross")), 7));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::Crosshairs")), 8));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::Hand")), 9));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::GrabHand")), 10));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::GrabHandClosed")), 11));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::SlashedCircle")), 12));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::EyeDropper")), 13));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EMouseCursor::EMouseCursor_MAX")), 14));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EMouseCursor::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("CardinalCross.ToolTip"), TEXT("MoveItem."));
			MetaData->SetValue(ReturnEnum, TEXT("Crosshairs.ToolTip"), TEXT("Target Cross."));
			MetaData->SetValue(ReturnEnum, TEXT("Default.ToolTip"), TEXT("Default cursor (arrow)."));
			MetaData->SetValue(ReturnEnum, TEXT("EyeDropper.ToolTip"), TEXT("Eye-dropper cursor for picking colors."));
			MetaData->SetValue(ReturnEnum, TEXT("GrabHand.ToolTip"), TEXT("Grab Hand cursor."));
			MetaData->SetValue(ReturnEnum, TEXT("GrabHandClosed.ToolTip"), TEXT("Grab Hand cursor closed."));
			MetaData->SetValue(ReturnEnum, TEXT("Hand.ToolTip"), TEXT("Hand cursor."));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("None.ToolTip"), TEXT("Causes no mouse cursor to be visible."));
			MetaData->SetValue(ReturnEnum, TEXT("ResizeLeftRight.ToolTip"), TEXT("Resize horizontal."));
			MetaData->SetValue(ReturnEnum, TEXT("ResizeSouthEast.ToolTip"), TEXT("Resize diagonal."));
			MetaData->SetValue(ReturnEnum, TEXT("ResizeSouthWest.ToolTip"), TEXT("Resize other diagonal."));
			MetaData->SetValue(ReturnEnum, TEXT("ResizeUpDown.ToolTip"), TEXT("Resize vertical."));
			MetaData->SetValue(ReturnEnum, TEXT("SlashedCircle.ToolTip"), TEXT("a circle with a diagonal line through it."));
			MetaData->SetValue(ReturnEnum, TEXT("TextEditBeam.ToolTip"), TEXT("Text edit beam."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_EMouseCursor_CRC() { return 2013134982U; }
	UEnum* Z_Construct_UEnum_CoreUObject_EPixelFormat()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_EPixelFormat_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EPixelFormat"), 0, Get_Z_Construct_UEnum_CoreUObject_EPixelFormat_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EPixelFormat"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_Unknown")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A32B32G32R32F")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_B8G8R8A8")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G8")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G16")), 4));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_DXT1")), 5));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_DXT3")), 6));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_DXT5")), 7));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_UYVY")), 8));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_FloatRGB")), 9));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_FloatRGBA")), 10));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_DepthStencil")), 11));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ShadowDepth")), 12));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R32_FLOAT")), 13));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G16R16")), 14));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G16R16F")), 15));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G16R16F_FILTER")), 16));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_G32R32F")), 17));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A2B10G10R10")), 18));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A16B16G16R16")), 19));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_D24")), 20));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16F")), 21));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16F_FILTER")), 22));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_BC5")), 23));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_V8U8")), 24));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A1")), 25));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_FloatR11G11B10")), 26));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A8")), 27));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R32_UINT")), 28));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R32_SINT")), 29));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_PVRTC2")), 30));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_PVRTC4")), 31));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16_UINT")), 32));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16_SINT")), 33));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16G16B16A16_UINT")), 34));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16G16B16A16_SINT")), 35));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R5G6B5_UNORM")), 36));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R8G8B8A8")), 37));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_A8R8G8B8")), 38));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_BC4")), 39));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R8G8")), 40));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ATC_RGB")), 41));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ATC_RGBA_E")), 42));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ATC_RGBA_I")), 43));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_X24_G8")), 44));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ETC1")), 45));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ETC2_RGB")), 46));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ETC2_RGBA")), 47));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R32G32B32A32_UINT")), 48));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R16G16_UINT")), 49));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ASTC_4x4")), 50));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ASTC_6x6")), 51));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ASTC_8x8")), 52));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ASTC_10x10")), 53));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_ASTC_12x12")), 54));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_BC6H")), 55));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_BC7")), 56));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_R8_UINT")), 57));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("PF_MAX")), 58));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EPixelFormat");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_A8R8G8B8.ToolTip"), TEXT("Only used for legacy loading; do NOT use!"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ASTC_10x10.ToolTip"), TEXT("1.28 bpp"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ASTC_12x12.ToolTip"), TEXT("0.89 bpp"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ASTC_4x4.ToolTip"), TEXT("8.00 bpp"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ASTC_6x6.ToolTip"), TEXT("3.56 bpp"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ASTC_8x8.ToolTip"), TEXT("2.00 bpp"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ATC_RGB.ToolTip"), TEXT("ATITC format."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ATC_RGBA_E.ToolTip"), TEXT("ATITC format."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ATC_RGBA_I.ToolTip"), TEXT("ATITC format."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_BC4.ToolTip"), TEXT("High precision single channel block compressed, equivalent to a single channel BC5, 8 bytes per 4x4 block."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_DepthStencil.ToolTip"), TEXT("A depth+stencil format with platform-specific implementation, for use with render targets."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_FloatR11G11B10.ToolTip"), TEXT("A low precision floating point format."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_FloatRGB.ToolTip"), TEXT("A RGB FP format with platform-specific implementation, for use with render targets."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_FloatRGBA.ToolTip"), TEXT("A RGBA FP format with platform-specific implementation, for use with render targets."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_G8.ToolTip"), TEXT("UNORM red (0..1)"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_R8G8.ToolTip"), TEXT("UNORM red, green (0..1)."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_ShadowDepth.ToolTip"), TEXT("A depth format with platform-specific implementation, for use with render targets."));
			MetaData->SetValue(ReturnEnum, TEXT("PF_V8U8.ToolTip"), TEXT("SNORM red, green (-1..1). Not supported on all RHI e.g. Metal"));
			MetaData->SetValue(ReturnEnum, TEXT("PF_X24_G8.ToolTip"), TEXT("Used for creating SRVs to alias a DepthStencil buffer to read Stencil.  Don't use for creating textures."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("@warning:      When you update this, you must add an entry to GPixelFormats(see RenderUtils.cpp)\n@warning:     When you update this, you must add an entries to PixelFormat.h, usually just copy the generated section on the header into EPixelFormat\n@warning:     The *Tools DLLs will also need to be recompiled if the ordering is changed, but should not need code changes."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_EPixelFormat_CRC() { return 2522691229U; }
	UEnum* Z_Construct_UEnum_CoreUObject_EInterpCurveMode()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_EInterpCurveMode_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EInterpCurveMode"), 0, Get_Z_Construct_UEnum_CoreUObject_EInterpCurveMode_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EInterpCurveMode"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_Linear")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_CurveAuto")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_Constant")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_CurveUser")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_CurveBreak")), 4));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_CurveAutoClamped")), 5));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("CIM_MAX")), 6));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EInterpCurveMode");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("CIM_Constant.DisplayName"), TEXT("Constant"));
			MetaData->SetValue(ReturnEnum, TEXT("CIM_CurveAuto.DisplayName"), TEXT("Curve Auto"));
			MetaData->SetValue(ReturnEnum, TEXT("CIM_CurveAutoClamped.DisplayName"), TEXT("Curve Auto Clamped"));
			MetaData->SetValue(ReturnEnum, TEXT("CIM_CurveBreak.DisplayName"), TEXT("Curve Break"));
			MetaData->SetValue(ReturnEnum, TEXT("CIM_CurveUser.DisplayName"), TEXT("Curve User"));
			MetaData->SetValue(ReturnEnum, TEXT("CIM_Linear.DisplayName"), TEXT("Linear"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Interpolation data types."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_EInterpCurveMode_CRC() { return 1093432446U; }
	UEnum* Z_Construct_UEnum_CoreUObject_EAxis()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_EAxis_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EAxis"), 0, Get_Z_Construct_UEnum_CoreUObject_EAxis_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EAxis"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EAxis::None")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EAxis::X")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EAxis::Y")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EAxis::Z")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("EAxis::EAxis_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("EAxis::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Generic axis enum (mirrored for native use in Axis.h)."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_EAxis_CRC() { return 1596831059U; }
	UEnum* Z_Construct_UEnum_CoreUObject_ELogTimes()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_ELogTimes_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ELogTimes"), 0, Get_Z_Construct_UEnum_CoreUObject_ELogTimes_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ELogTimes"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ELogTimes::None")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ELogTimes::UTC")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ELogTimes::SinceGStartTime")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ELogTimes::ELogTimes_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("ELogTimes::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("None.ToolTip"), TEXT("Do not display log timestamps."));
			MetaData->SetValue(ReturnEnum, TEXT("SinceGStartTime.DisplayName"), TEXT("Time since application start"));
			MetaData->SetValue(ReturnEnum, TEXT("SinceGStartTime.ToolTip"), TEXT("Display log timestamps in seconds elapsed since GStartTime."));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Enum that defines how the log times are to be displayed (mirrored from OutputDevice.h)."));
			MetaData->SetValue(ReturnEnum, TEXT("UTC.DisplayName"), TEXT("UTC"));
			MetaData->SetValue(ReturnEnum, TEXT("UTC.ToolTip"), TEXT("Display log timestamps in UTC."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_ELogTimes_CRC() { return 1013539820U; }
	UEnum* Z_Construct_UEnum_CoreUObject_ESearchDir()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_ESearchDir_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESearchDir"), 0, Get_Z_Construct_UEnum_CoreUObject_ESearchDir_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESearchDir"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchDir::FromStart")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchDir::FromEnd")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchDir::ESearchDir_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("ESearchDir::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("String search dir used in UnrealString.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_ESearchDir_CRC() { return 4241538361U; }
	UEnum* Z_Construct_UEnum_CoreUObject_ESearchCase()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_ESearchCase_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ESearchCase"), 0, Get_Z_Construct_UEnum_CoreUObject_ESearchCase_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ESearchCase"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchCase::CaseSensitive")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchCase::IgnoreCase")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("ESearchCase::ESearchCase_MAX")), 2));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Namespaced);
			ReturnEnum->CppType = TEXT("ESearchCase::Type");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("String search case used in UnrealString.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_ESearchCase_CRC() { return 1415084780U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInt32Interval()
	{
		struct FInt32Interval
		{
			int32 Min;
			int32 Max;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInt32Interval_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Int32Interval"), sizeof(FInt32Interval), Get_Z_Construct_UScriptStruct_FInt32Interval_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Int32Interval"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInt32Interval), ALIGNOF(FInt32Interval));
			UProperty* NewProp_Max = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Max"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Max, FInt32Interval), 0x0010000000000001);
			UProperty* NewProp_Min = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Min"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Min, FInt32Interval), 0x0010000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("An int32 interval"));
			MetaData->SetValue(NewProp_Max, TEXT("Category"), TEXT("Interval"));
			MetaData->SetValue(NewProp_Max, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Min, TEXT("Category"), TEXT("Interval"));
			MetaData->SetValue(NewProp_Min, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInt32Interval_CRC() { return 3669756289U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFloatInterval()
	{
		struct FFloatInterval
		{
			float Min;
			float Max;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FFloatInterval_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FloatInterval"), sizeof(FFloatInterval), Get_Z_Construct_UScriptStruct_FFloatInterval_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FloatInterval"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FFloatInterval), ALIGNOF(FFloatInterval));
			UProperty* NewProp_Max = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Max"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Max, FFloatInterval), 0x0010000000000001);
			UProperty* NewProp_Min = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Min"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Min, FFloatInterval), 0x0010000000000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A float interval"));
			MetaData->SetValue(NewProp_Max, TEXT("Category"), TEXT("Interval"));
			MetaData->SetValue(NewProp_Max, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Min, TEXT("Category"), TEXT("Interval"));
			MetaData->SetValue(NewProp_Min, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFloatInterval_CRC() { return 217841754U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInt32Range()
	{
		struct FInt32RangeBound
		{
			TEnumAsByte<ERangeBoundTypes::Type> Type;
			int32 Value;
		};

		struct FInt32Range
		{
			FInt32RangeBound LowerBound;
			FInt32RangeBound UpperBound;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInt32Range_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Int32Range"), sizeof(FInt32Range), Get_Z_Construct_UScriptStruct_FInt32Range_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Int32Range"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInt32Range), ALIGNOF(FInt32Range));
			UProperty* NewProp_UpperBound = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("UpperBound"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(UpperBound, FInt32Range), 0x0010000000000001, Z_Construct_UScriptStruct_FInt32RangeBound());
			UProperty* NewProp_LowerBound = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LowerBound"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LowerBound, FInt32Range), 0x0010000000000001, Z_Construct_UScriptStruct_FInt32RangeBound());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("An int32 range"));
			MetaData->SetValue(NewProp_UpperBound, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_UpperBound, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LowerBound, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_LowerBound, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInt32Range_CRC() { return 3950082276U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInt32RangeBound()
	{
		struct FInt32RangeBound
		{
			TEnumAsByte<ERangeBoundTypes::Type> Type;
			int32 Value;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInt32RangeBound_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Int32RangeBound"), sizeof(FInt32RangeBound), Get_Z_Construct_UScriptStruct_FInt32RangeBound_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Int32RangeBound"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInt32RangeBound), ALIGNOF(FInt32RangeBound));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Value"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Value, FInt32RangeBound), 0x0010000000000001);
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, FInt32RangeBound), 0x0010000000000001, Z_Construct_UEnum_CoreUObject_ERangeBoundTypes());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("An int32 range bound"));
			MetaData->SetValue(NewProp_Value, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_Value, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInt32RangeBound_CRC() { return 432813373U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFloatRange()
	{
		struct FFloatRangeBound
		{
			TEnumAsByte<ERangeBoundTypes::Type> Type;
			float Value;
		};

		struct FFloatRange
		{
			FFloatRangeBound LowerBound;
			FFloatRangeBound UpperBound;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FFloatRange_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FloatRange"), sizeof(FFloatRange), Get_Z_Construct_UScriptStruct_FFloatRange_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FloatRange"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FFloatRange), ALIGNOF(FFloatRange));
			UProperty* NewProp_UpperBound = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("UpperBound"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(UpperBound, FFloatRange), 0x0010000000000001, Z_Construct_UScriptStruct_FFloatRangeBound());
			UProperty* NewProp_LowerBound = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LowerBound"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LowerBound, FFloatRange), 0x0010000000000001, Z_Construct_UScriptStruct_FFloatRangeBound());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A float range"));
			MetaData->SetValue(NewProp_UpperBound, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_UpperBound, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LowerBound, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_LowerBound, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFloatRange_CRC() { return 522797267U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFloatRangeBound()
	{
		struct FFloatRangeBound
		{
			TEnumAsByte<ERangeBoundTypes::Type> Type;
			float Value;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FFloatRangeBound_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FloatRangeBound"), sizeof(FFloatRangeBound), Get_Z_Construct_UScriptStruct_FFloatRangeBound_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FloatRangeBound"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FFloatRangeBound), ALIGNOF(FFloatRangeBound));
			UProperty* NewProp_Value = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Value"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Value, FFloatRangeBound), 0x0010000000000001);
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, FFloatRangeBound), 0x0010000000000001, Z_Construct_UEnum_CoreUObject_ERangeBoundTypes());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A float range bound"));
			MetaData->SetValue(NewProp_Value, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_Value, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("Range"));
			MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFloatRangeBound_CRC() { return 3744780213U; }
	UScriptStruct* Z_Construct_UScriptStruct_FFallbackStruct()
	{
		struct FFallbackStruct
		{
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FFallbackStruct_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("FallbackStruct"), sizeof(FFallbackStruct), Get_Z_Construct_UScriptStruct_FFallbackStruct_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FallbackStruct"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FFallbackStruct), ALIGNOF(FFallbackStruct));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A struct used as stub for deleted ones."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FFallbackStruct_CRC() { return 3711311475U; }
	UScriptStruct* Z_Construct_UScriptStruct_FStringClassReference()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FStringClassReference_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("StringClassReference"), sizeof(FStringClassReference), Get_Z_Construct_UScriptStruct_FStringClassReference_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StringClassReference"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FStringAssetReference(), NULL, EStructFlags(0x00000008), sizeof(FStringClassReference), ALIGNOF(FStringClassReference));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A string class reference"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FStringClassReference_CRC() { return 2622609911U; }
	UScriptStruct* Z_Construct_UScriptStruct_FStringAssetReference()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FStringAssetReference_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("StringAssetReference"), sizeof(FStringAssetReference), Get_Z_Construct_UScriptStruct_FStringAssetReference_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StringAssetReference"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FStringAssetReference), ALIGNOF(FStringAssetReference));
			UProperty* NewProp_AssetLongPathname = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AssetLongPathname"), RF_Public|RF_Transient|RF_MarkAsNative) UStrProperty(CPP_PROPERTY_BASE(AssetLongPathname, FStringAssetReference), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.BlueprintFunctionLibrary.MakeStringAssetReference"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A string asset reference"));
			MetaData->SetValue(NewProp_AssetLongPathname, TEXT("Category"), TEXT("StringAssetReference"));
			MetaData->SetValue(NewProp_AssetLongPathname, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FStringAssetReference_CRC() { return 1053501159U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTimespan()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimespan_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Timespan"), sizeof(FTimespan), Get_Z_Construct_UScriptStruct_FTimespan_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Timespan"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FTimespan), ALIGNOF(FTimespan));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakTimespan"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeTimespan"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A time span value."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimespan_CRC() { return 2009286673U; }
	UScriptStruct* Z_Construct_UScriptStruct_FDateTime()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FDateTime_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("DateTime"), sizeof(FDateTime), Get_Z_Construct_UScriptStruct_FDateTime_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DateTime"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FDateTime), ALIGNOF(FDateTime));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakDateTime"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeDateTime"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A date/time value."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FDateTime_CRC() { return 548968559U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRandomStream()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FRandomStream_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("RandomStream"), sizeof(FRandomStream), Get_Z_Construct_UScriptStruct_FRandomStream_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RandomStream"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FRandomStream), ALIGNOF(FRandomStream));
			UProperty* NewProp_Seed = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Seed"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Seed, FRandomStream), 0x0010000000000000);
			UProperty* NewProp_InitialSeed = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InitialSeed"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(InitialSeed, FRandomStream), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakRandomStream"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeRandomStream"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Thread-safe RNG.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\RandomStream.h"));
			MetaData->SetValue(NewProp_Seed, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InitialSeed, TEXT("Category"), TEXT("RandomStream"));
			MetaData->SetValue(NewProp_InitialSeed, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRandomStream_CRC() { return 1865118544U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTransform()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FTransform_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Transform"), sizeof(FTransform), Get_Z_Construct_UScriptStruct_FTransform_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Transform"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FTransform), ALIGNOF(FTransform));
			UProperty* NewProp_Scale3D = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Scale3D"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Scale3D, FTransform), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Translation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Translation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Translation, FTransform), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Rotation, FTransform), 0x0010000001000005, Z_Construct_UScriptStruct_FQuat());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakTransform"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeTransform"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Transform composed of Quat/Translation/Scale.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Transform.h"));
			MetaData->SetValue(NewProp_Scale3D, TEXT("Category"), TEXT("Transform"));
			MetaData->SetValue(NewProp_Scale3D, TEXT("MakeStructureDefaultValue"), TEXT("1,1,1"));
			MetaData->SetValue(NewProp_Scale3D, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Translation, TEXT("Category"), TEXT("Transform"));
			MetaData->SetValue(NewProp_Translation, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("Category"), TEXT("Transform"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTransform_CRC() { return 1151860601U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveLinearColor()
	{
		struct FInterpCurvePointLinearColor
		{
			float InVal;
			FLinearColor OutVal;
			FLinearColor ArriveTangent;
			FLinearColor LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveLinearColor
		{
			TArray<FInterpCurvePointLinearColor> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveLinearColor_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveLinearColor"), sizeof(FInterpCurveLinearColor), Get_Z_Construct_UScriptStruct_FInterpCurveLinearColor_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveLinearColor"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveLinearColor), ALIGNOF(FInterpCurveLinearColor));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveLinearColor), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveLinearColor, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveLinearColor), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveLinearColor), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveLinearColor), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointLinearColor());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveLinearColor"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveLinearColor"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveLinearColor"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveLinearColor_CRC() { return 771626488U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointLinearColor()
	{
		struct FInterpCurvePointLinearColor
		{
			float InVal;
			FLinearColor OutVal;
			FLinearColor ArriveTangent;
			FLinearColor LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointLinearColor_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointLinearColor"), sizeof(FInterpCurvePointLinearColor), Get_Z_Construct_UScriptStruct_FInterpCurvePointLinearColor_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointLinearColor"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointLinearColor), ALIGNOF(FInterpCurvePointLinearColor));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointLinearColor), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointLinearColor), 0x0010000000000005, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointLinearColor), 0x0010000000000005, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointLinearColor), 0x0010000000000005, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointLinearColor), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointLinearColor"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointLinearColor"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointLinearColor"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointLinearColor"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointLinearColor"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointLinearColor_CRC() { return 231298574U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveTwoVectors()
	{
		struct FInterpCurvePointTwoVectors
		{
			float InVal;
			FTwoVectors OutVal;
			FTwoVectors ArriveTangent;
			FTwoVectors LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveTwoVectors
		{
			TArray<FInterpCurvePointTwoVectors> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveTwoVectors_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveTwoVectors"), sizeof(FInterpCurveTwoVectors), Get_Z_Construct_UScriptStruct_FInterpCurveTwoVectors_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveTwoVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveTwoVectors), ALIGNOF(FInterpCurveTwoVectors));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveTwoVectors), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveTwoVectors, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveTwoVectors), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveTwoVectors), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveTwoVectors), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveTwoVectors"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveTwoVectors"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveTwoVectors"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveTwoVectors_CRC() { return 621735577U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors()
	{
		struct FInterpCurvePointTwoVectors
		{
			float InVal;
			FTwoVectors OutVal;
			FTwoVectors ArriveTangent;
			FTwoVectors LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointTwoVectors"), sizeof(FInterpCurvePointTwoVectors), Get_Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointTwoVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointTwoVectors), ALIGNOF(FInterpCurvePointTwoVectors));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointTwoVectors), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointTwoVectors), 0x0010000000000005, Z_Construct_UScriptStruct_FTwoVectors());
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointTwoVectors), 0x0010000000000005, Z_Construct_UScriptStruct_FTwoVectors());
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointTwoVectors), 0x0010000000000005, Z_Construct_UScriptStruct_FTwoVectors());
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointTwoVectors), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointTwoVectors"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointTwoVectors"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointTwoVectors"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointTwoVectors"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointTwoVectors"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors_CRC() { return 2423883838U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveQuat()
	{
		struct FInterpCurvePointQuat
		{
			float InVal;
			FQuat OutVal;
			FQuat ArriveTangent;
			FQuat LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveQuat
		{
			TArray<FInterpCurvePointQuat> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveQuat_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveQuat"), sizeof(FInterpCurveQuat), Get_Z_Construct_UScriptStruct_FInterpCurveQuat_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveQuat"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveQuat), ALIGNOF(FInterpCurveQuat));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveQuat), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveQuat, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveQuat), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveQuat), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveQuat), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointQuat());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveQuat"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveQuat"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveQuat"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveQuat_CRC() { return 1776702504U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointQuat()
	{
		struct FInterpCurvePointQuat
		{
			float InVal;
			FQuat OutVal;
			FQuat ArriveTangent;
			FQuat LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointQuat_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointQuat"), sizeof(FInterpCurvePointQuat), Get_Z_Construct_UScriptStruct_FInterpCurvePointQuat_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointQuat"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointQuat), ALIGNOF(FInterpCurvePointQuat));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointQuat), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointQuat), 0x0010000000000005, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointQuat), 0x0010000000000005, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointQuat), 0x0010000000000005, Z_Construct_UScriptStruct_FQuat());
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointQuat), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointQuat"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointQuat"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointQuat"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointQuat"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointQuat"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointQuat_CRC() { return 1169187341U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector()
	{
		struct FInterpCurvePointVector
		{
			float InVal;
			FVector OutVal;
			FVector ArriveTangent;
			FVector LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveVector
		{
			TArray<FInterpCurvePointVector> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveVector_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveVector"), sizeof(FInterpCurveVector), Get_Z_Construct_UScriptStruct_FInterpCurveVector_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveVector"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveVector), ALIGNOF(FInterpCurveVector));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveVector), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveVector, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveVector), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveVector), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveVector), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveVector"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveVector"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveVector"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveVector_CRC() { return 1520337016U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointVector()
	{
		struct FInterpCurvePointVector
		{
			float InVal;
			FVector OutVal;
			FVector ArriveTangent;
			FVector LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointVector_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointVector"), sizeof(FInterpCurvePointVector), Get_Z_Construct_UScriptStruct_FInterpCurvePointVector_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointVector"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointVector), ALIGNOF(FInterpCurvePointVector));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointVector), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointVector), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointVector), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointVector), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointVector), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointVector"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointVector"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointVector"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointVector"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointVector"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointVector_CRC() { return 1023049570U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveVector2D()
	{
		struct FInterpCurvePointVector2D
		{
			float InVal;
			FVector2D OutVal;
			FVector2D ArriveTangent;
			FVector2D LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveVector2D
		{
			TArray<FInterpCurvePointVector2D> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveVector2D_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveVector2D"), sizeof(FInterpCurveVector2D), Get_Z_Construct_UScriptStruct_FInterpCurveVector2D_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveVector2D"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveVector2D), ALIGNOF(FInterpCurveVector2D));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveVector2D), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveVector2D, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveVector2D), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveVector2D), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveVector2D), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointVector2D());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveVector2D"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveVector2D"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveVector2D"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveVector2D_CRC() { return 565552144U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointVector2D()
	{
		struct FInterpCurvePointVector2D
		{
			float InVal;
			FVector2D OutVal;
			FVector2D ArriveTangent;
			FVector2D LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointVector2D_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointVector2D"), sizeof(FInterpCurvePointVector2D), Get_Z_Construct_UScriptStruct_FInterpCurvePointVector2D_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointVector2D"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointVector2D), ALIGNOF(FInterpCurvePointVector2D));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointVector2D), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointVector2D), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointVector2D), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointVector2D), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointVector2D), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointVector2D"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointVector2D"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointVector2D"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointVector2D"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointVector2D"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointVector2D_CRC() { return 712522036U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurveFloat()
	{
		struct FInterpCurvePointFloat
		{
			float InVal;
			float OutVal;
			float ArriveTangent;
			float LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		struct FInterpCurveFloat
		{
			TArray<FInterpCurvePointFloat> Points;
			bool bIsLooped;
			float LoopKeyOffset;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurveFloat_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurveFloat"), sizeof(FInterpCurveFloat), Get_Z_Construct_UScriptStruct_FInterpCurveFloat_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurveFloat"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurveFloat), ALIGNOF(FInterpCurveFloat));
			UProperty* NewProp_LoopKeyOffset = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LoopKeyOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LoopKeyOffset, FInterpCurveFloat), 0x0010000000000005);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bIsLooped, FInterpCurveFloat, bool);
			UProperty* NewProp_bIsLooped = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bIsLooped"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bIsLooped, FInterpCurveFloat), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bIsLooped, FInterpCurveFloat), sizeof(bool), true);
			UProperty* NewProp_Points = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(Points, FInterpCurveFloat), 0x0010000000000005);
			UProperty* NewProp_Points_Inner = new(EC_InternalUseOnlyConstructor, NewProp_Points, TEXT("Points"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FInterpCurvePointFloat());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("Category"), TEXT("InterpCurveFloat"));
			MetaData->SetValue(NewProp_LoopKeyOffset, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("Category"), TEXT("InterpCurveFloat"));
			MetaData->SetValue(NewProp_bIsLooped, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Points, TEXT("Category"), TEXT("InterpCurveFloat"));
			MetaData->SetValue(NewProp_Points, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurveFloat_CRC() { return 2246984535U; }
	UScriptStruct* Z_Construct_UScriptStruct_FInterpCurvePointFloat()
	{
		struct FInterpCurvePointFloat
		{
			float InVal;
			float OutVal;
			float ArriveTangent;
			float LeaveTangent;
			TEnumAsByte<EInterpCurveMode> InterpMode;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointFloat_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("InterpCurvePointFloat"), sizeof(FInterpCurvePointFloat), Get_Z_Construct_UScriptStruct_FInterpCurvePointFloat_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InterpCurvePointFloat"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FInterpCurvePointFloat), ALIGNOF(FInterpCurvePointFloat));
			UProperty* NewProp_InterpMode = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InterpMode"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(InterpMode, FInterpCurvePointFloat), 0x0010000000000005, Z_Construct_UEnum_CoreUObject_EInterpCurveMode());
			UProperty* NewProp_LeaveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("LeaveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LeaveTangent, FInterpCurvePointFloat), 0x0010000000000005);
			UProperty* NewProp_ArriveTangent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ArriveTangent"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ArriveTangent, FInterpCurvePointFloat), 0x0010000000000005);
			UProperty* NewProp_OutVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("OutVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(OutVal, FInterpCurvePointFloat), 0x0010000000000005);
			UProperty* NewProp_InVal = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("InVal"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(InVal, FInterpCurvePointFloat), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("Category"), TEXT("InterpCurvePointFloat"));
			MetaData->SetValue(NewProp_InterpMode, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("Category"), TEXT("InterpCurvePointFloat"));
			MetaData->SetValue(NewProp_LeaveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("Category"), TEXT("InterpCurvePointFloat"));
			MetaData->SetValue(NewProp_ArriveTangent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_OutVal, TEXT("Category"), TEXT("InterpCurvePointFloat"));
			MetaData->SetValue(NewProp_OutVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_InVal, TEXT("Category"), TEXT("InterpCurvePointFloat"));
			MetaData->SetValue(NewProp_InVal, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FInterpCurvePointFloat_CRC() { return 3101596676U; }
	UScriptStruct* Z_Construct_UScriptStruct_FMatrix()
	{
		struct FMatrix
		{
			FPlane XPlane;
			FPlane YPlane;
			FPlane ZPlane;
			FPlane WPlane;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FMatrix_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Matrix"), sizeof(FMatrix), Get_Z_Construct_UScriptStruct_FMatrix_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Matrix"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FMatrix), ALIGNOF(FMatrix));
			UProperty* NewProp_WPlane = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("WPlane"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WPlane, FMatrix), 0x0010000001000005, Z_Construct_UScriptStruct_FPlane());
			UProperty* NewProp_ZPlane = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ZPlane"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ZPlane, FMatrix), 0x0010000001000005, Z_Construct_UScriptStruct_FPlane());
			UProperty* NewProp_YPlane = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("YPlane"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(YPlane, FMatrix), 0x0010000001000005, Z_Construct_UScriptStruct_FPlane());
			UProperty* NewProp_XPlane = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("XPlane"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(XPlane, FMatrix), 0x0010000001000005, Z_Construct_UScriptStruct_FPlane());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("* A 4x4 matrix.\n* The full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Matrix.h"));
			MetaData->SetValue(NewProp_WPlane, TEXT("Category"), TEXT("Matrix"));
			MetaData->SetValue(NewProp_WPlane, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ZPlane, TEXT("Category"), TEXT("Matrix"));
			MetaData->SetValue(NewProp_ZPlane, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_YPlane, TEXT("Category"), TEXT("Matrix"));
			MetaData->SetValue(NewProp_YPlane, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_XPlane, TEXT("Category"), TEXT("Matrix"));
			MetaData->SetValue(NewProp_XPlane, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FMatrix_CRC() { return 3967021839U; }
	UScriptStruct* Z_Construct_UScriptStruct_FOrientedBox()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FOrientedBox_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("OrientedBox"), sizeof(FOrientedBox), Get_Z_Construct_UScriptStruct_FOrientedBox_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OrientedBox"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FOrientedBox), ALIGNOF(FOrientedBox));
			UProperty* NewProp_ExtentZ = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ExtentZ"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ExtentZ, FOrientedBox), 0x0010000001000005);
			UProperty* NewProp_ExtentY = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ExtentY"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ExtentY, FOrientedBox), 0x0010000001000005);
			UProperty* NewProp_ExtentX = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ExtentX"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ExtentX, FOrientedBox), 0x0010000001000005);
			UProperty* NewProp_AxisZ = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AxisZ"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AxisZ, FOrientedBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AxisY = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AxisY"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AxisY, FOrientedBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_AxisX = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("AxisX"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(AxisX, FOrientedBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Center"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Center, FOrientedBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Structure for arbitrarily oriented boxes (i.e. not necessarily axis-aligned).\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\OrientedBox.h"));
			MetaData->SetValue(NewProp_ExtentZ, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_ExtentZ, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ExtentY, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_ExtentY, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_ExtentX, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_ExtentX, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_AxisZ, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_AxisZ, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_AxisY, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_AxisY, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_AxisX, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_AxisX, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Center, TEXT("Category"), TEXT("OrientedBox"));
			MetaData->SetValue(NewProp_Center, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FOrientedBox_CRC() { return 2926220294U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBoxSphereBounds()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FBoxSphereBounds_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("BoxSphereBounds"), sizeof(FBoxSphereBounds), Get_Z_Construct_UScriptStruct_FBoxSphereBounds_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("BoxSphereBounds"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FBoxSphereBounds), ALIGNOF(FBoxSphereBounds));
			UProperty* NewProp_SphereRadius = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SphereRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SphereRadius, FBoxSphereBounds), 0x0010000001000005);
			UProperty* NewProp_BoxExtent = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoxExtent"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(BoxExtent, FBoxSphereBounds), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Origin = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Origin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Origin, FBoxSphereBounds), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A bounding box and bounding sphere with the same origin.\nThe full C++ class is located here : Engine\\Source\\Runtime\\Core\\Public\\Math\\BoxSphereBounds.h"));
			MetaData->SetValue(NewProp_SphereRadius, TEXT("Category"), TEXT("BoxSphereBounds"));
			MetaData->SetValue(NewProp_SphereRadius, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_BoxExtent, TEXT("Category"), TEXT("BoxSphereBounds"));
			MetaData->SetValue(NewProp_BoxExtent, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Origin, TEXT("Category"), TEXT("BoxSphereBounds"));
			MetaData->SetValue(NewProp_Origin, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBoxSphereBounds_CRC() { return 376176304U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBox2D()
	{
		struct FBox2D
		{
			FVector2D Min;
			FVector2D Max;
			uint8 IsValid;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FBox2D_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Box2D"), sizeof(FBox2D), Get_Z_Construct_UScriptStruct_FBox2D_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Box2D"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FBox2D), ALIGNOF(FBox2D));
			UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(IsValid, FBox2D), 0x0010000000000000);
			UProperty* NewProp_Max = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Max"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Max, FBox2D), 0x0010000001000005, Z_Construct_UScriptStruct_FVector2D());
			UProperty* NewProp_Min = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Min"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Min, FBox2D), 0x0010000001000005, Z_Construct_UScriptStruct_FVector2D());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeBox2D"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A rectangular 2D Box.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Box2D.h"));
			MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Max, TEXT("Category"), TEXT("Box2D"));
			MetaData->SetValue(NewProp_Max, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Min, TEXT("Category"), TEXT("Box2D"));
			MetaData->SetValue(NewProp_Min, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBox2D_CRC() { return 2447921188U; }
	UScriptStruct* Z_Construct_UScriptStruct_FBox()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FBox_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Box"), sizeof(FBox), Get_Z_Construct_UScriptStruct_FBox_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Box"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FBox), ALIGNOF(FBox));
			UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(IsValid, FBox), 0x0010000000000000);
			UProperty* NewProp_Max = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Max"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Max, FBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Min = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Min"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Min, FBox), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeBox"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A bounding box.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Box.h"));
			MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Max, TEXT("Category"), TEXT("Box"));
			MetaData->SetValue(NewProp_Max, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Min, TEXT("Category"), TEXT("Box"));
			MetaData->SetValue(NewProp_Min, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FBox_CRC() { return 429826212U; }
	UScriptStruct* Z_Construct_UScriptStruct_FLinearColor()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FLinearColor_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("LinearColor"), sizeof(FLinearColor), Get_Z_Construct_UScriptStruct_FLinearColor_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LinearColor"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FLinearColor), ALIGNOF(FLinearColor));
			UProperty* NewProp_A = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("A"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(A, FLinearColor), 0x0010000001000005);
			UProperty* NewProp_B = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("B"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(B, FLinearColor), 0x0010000001000005);
			UProperty* NewProp_G = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("G"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(G, FLinearColor), 0x0010000001000005);
			UProperty* NewProp_R = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("R"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(R, FLinearColor), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A linear color.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Color.h"));
			MetaData->SetValue(NewProp_A, TEXT("Category"), TEXT("LinearColor"));
			MetaData->SetValue(NewProp_A, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_B, TEXT("Category"), TEXT("LinearColor"));
			MetaData->SetValue(NewProp_B, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_G, TEXT("Category"), TEXT("LinearColor"));
			MetaData->SetValue(NewProp_G, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_R, TEXT("Category"), TEXT("LinearColor"));
			MetaData->SetValue(NewProp_R, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FLinearColor_CRC() { return 2299644988U; }
	UScriptStruct* Z_Construct_UScriptStruct_FColor()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FColor_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Color"), sizeof(FColor), Get_Z_Construct_UScriptStruct_FColor_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Color"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FColor), ALIGNOF(FColor));
			UProperty* NewProp_A = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("A"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(A, FColor), 0x0010000001000005);
			UProperty* NewProp_R = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("R"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(R, FColor), 0x0010000001000005);
			UProperty* NewProp_G = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("G"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(G, FColor), 0x0010000001000005);
			UProperty* NewProp_B = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("B"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(B, FColor), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A Color (BGRA).\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Color.h"));
			MetaData->SetValue(NewProp_A, TEXT("Category"), TEXT("Color"));
			MetaData->SetValue(NewProp_A, TEXT("ClampMax"), TEXT("255"));
			MetaData->SetValue(NewProp_A, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_A, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_R, TEXT("Category"), TEXT("Color"));
			MetaData->SetValue(NewProp_R, TEXT("ClampMax"), TEXT("255"));
			MetaData->SetValue(NewProp_R, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_R, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_G, TEXT("Category"), TEXT("Color"));
			MetaData->SetValue(NewProp_G, TEXT("ClampMax"), TEXT("255"));
			MetaData->SetValue(NewProp_G, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_G, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_B, TEXT("Category"), TEXT("Color"));
			MetaData->SetValue(NewProp_B, TEXT("ClampMax"), TEXT("255"));
			MetaData->SetValue(NewProp_B, TEXT("ClampMin"), TEXT("0"));
			MetaData->SetValue(NewProp_B, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FColor_CRC() { return 1125213570U; }
	UScriptStruct* Z_Construct_UScriptStruct_FIntVector()
	{
		struct FIntVector
		{
			int32 X;
			int32 Y;
			int32 Z;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FIntVector_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("IntVector"), sizeof(FIntVector), Get_Z_Construct_UScriptStruct_FIntVector_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IntVector"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FIntVector), ALIGNOF(FIntVector));
			UProperty* NewProp_Z = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Z"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Z, FIntVector), 0x0010000001000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Y, FIntVector), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(X, FIntVector), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("An integer vector in 3D space.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\IntVector.h"));
			MetaData->SetValue(NewProp_Z, TEXT("Category"), TEXT("IntVector"));
			MetaData->SetValue(NewProp_Z, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("IntVector"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("IntVector"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FIntVector_CRC() { return 3317318525U; }
	UScriptStruct* Z_Construct_UScriptStruct_FIntPoint()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FIntPoint_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("IntPoint"), sizeof(FIntPoint), Get_Z_Construct_UScriptStruct_FIntPoint_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IntPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FIntPoint), ALIGNOF(FIntPoint));
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Y, FIntPoint), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(X, FIntPoint), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Screen coordinates.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\IntPoint.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("IntPoint"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("IntPoint"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FIntPoint_CRC() { return 1696445495U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPackedRGBA16N()
	{
		struct FPackedRGBA16N
		{
			int32 XY;
			int32 ZW;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FPackedRGBA16N_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("PackedRGBA16N"), sizeof(FPackedRGBA16N), Get_Z_Construct_UScriptStruct_FPackedRGBA16N_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PackedRGBA16N"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FPackedRGBA16N), ALIGNOF(FPackedRGBA16N));
			UProperty* NewProp_ZW = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("ZW"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(ZW, FPackedRGBA16N), 0x0010000001000005);
			UProperty* NewProp_XY = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("XY"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(XY, FPackedRGBA16N), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A packed vector.\nThe full C++ class is located here: Engine\\Source\\Runtime\\RenderCore\\Public\\PackedNormal.h"));
			MetaData->SetValue(NewProp_ZW, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_ZW, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_XY, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_XY, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPackedRGBA16N_CRC() { return 180165003U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPackedRGB10A2N()
	{
		struct FPackedRGB10A2N
		{
			int32 Packed;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FPackedRGB10A2N_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("PackedRGB10A2N"), sizeof(FPackedRGB10A2N), Get_Z_Construct_UScriptStruct_FPackedRGB10A2N_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PackedRGB10A2N"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FPackedRGB10A2N), ALIGNOF(FPackedRGB10A2N));
			UProperty* NewProp_Packed = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Packed"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Packed, FPackedRGB10A2N), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A packed basis vector.\nThe full C++ class is located here: Engine\\Source\\Runtime\\RenderCore\\Public\\PackedNormal.h"));
			MetaData->SetValue(NewProp_Packed, TEXT("Category"), TEXT("PackedBasis"));
			MetaData->SetValue(NewProp_Packed, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPackedRGB10A2N_CRC() { return 362641367U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPackedNormal()
	{
		struct FPackedNormal
		{
			uint8 X;
			uint8 Y;
			uint8 Z;
			uint8 W;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FPackedNormal_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("PackedNormal"), sizeof(FPackedNormal), Get_Z_Construct_UScriptStruct_FPackedNormal_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("PackedNormal"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FPackedNormal), ALIGNOF(FPackedNormal));
			UProperty* NewProp_W = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("W"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(W, FPackedNormal), 0x0010000001000005);
			UProperty* NewProp_Z = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Z"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Z, FPackedNormal), 0x0010000001000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Y, FPackedNormal), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(X, FPackedNormal), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A packed normal.\nThe full C++ class is located here: Engine\\Source\\Runtime\\RenderCore\\Public\\PackedNormal.h"));
			MetaData->SetValue(NewProp_W, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_W, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Z, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_Z, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("PackedNormal"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPackedNormal_CRC() { return 3248194524U; }
	UScriptStruct* Z_Construct_UScriptStruct_FQuat()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FQuat_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Quat"), sizeof(FQuat), Get_Z_Construct_UScriptStruct_FQuat_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Quat"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FQuat), ALIGNOF(FQuat));
			UProperty* NewProp_W = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("W"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(W, FQuat), 0x0010000001000005);
			UProperty* NewProp_Z = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Z"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Z, FQuat), 0x0010000001000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Y, FQuat), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(X, FQuat), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Quaternion.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Quat.h"));
			MetaData->SetValue(NewProp_W, TEXT("Category"), TEXT("Quat"));
			MetaData->SetValue(NewProp_W, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Z, TEXT("Category"), TEXT("Quat"));
			MetaData->SetValue(NewProp_Z, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("Quat"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("Quat"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FQuat_CRC() { return 3881081135U; }
	UScriptStruct* Z_Construct_UScriptStruct_FRotator()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FRotator_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Rotator"), sizeof(FRotator), Get_Z_Construct_UScriptStruct_FRotator_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rotator"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FRotator), ALIGNOF(FRotator));
			UProperty* NewProp_Roll = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Roll"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Roll, FRotator), 0x0010000001000005);
			UProperty* NewProp_Yaw = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Yaw"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Yaw, FRotator), 0x0010000001000005);
			UProperty* NewProp_Pitch = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Pitch"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Pitch, FRotator), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakRotator"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeRotator"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("An orthogonal rotation in 3d space.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Rotator.h"));
			MetaData->SetValue(NewProp_Roll, TEXT("Category"), TEXT("Rotator"));
			MetaData->SetValue(NewProp_Roll, TEXT("DisplayName"), TEXT("X"));
			MetaData->SetValue(NewProp_Roll, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Roll, TEXT("ToolTip"), TEXT("Roll (degrees) around X axis"));
			MetaData->SetValue(NewProp_Yaw, TEXT("Category"), TEXT("Rotator"));
			MetaData->SetValue(NewProp_Yaw, TEXT("DisplayName"), TEXT("Z"));
			MetaData->SetValue(NewProp_Yaw, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Yaw, TEXT("ToolTip"), TEXT("Yaw (degrees) around Z axis"));
			MetaData->SetValue(NewProp_Pitch, TEXT("Category"), TEXT("Rotator"));
			MetaData->SetValue(NewProp_Pitch, TEXT("DisplayName"), TEXT("Y"));
			MetaData->SetValue(NewProp_Pitch, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Pitch, TEXT("ToolTip"), TEXT("Pitch (degrees) around Y axis"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FRotator_CRC() { return 858045234U; }
	UScriptStruct* Z_Construct_UScriptStruct_FPlane()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FPlane_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Plane"), sizeof(FPlane), Get_Z_Construct_UScriptStruct_FPlane_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Plane"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), Z_Construct_UScriptStruct_FVector(), NULL, EStructFlags(0x00000038), sizeof(FPlane), ALIGNOF(FPlane));
			UProperty* NewProp_W = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("W"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(W, FPlane), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A plane definition in 3D space.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Plane.h"));
			MetaData->SetValue(NewProp_W, TEXT("Category"), TEXT("Plane"));
			MetaData->SetValue(NewProp_W, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FPlane_CRC() { return 1270221173U; }
	UScriptStruct* Z_Construct_UScriptStruct_FTwoVectors()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FTwoVectors_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("TwoVectors"), sizeof(FTwoVectors), Get_Z_Construct_UScriptStruct_FTwoVectors_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TwoVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FTwoVectors), ALIGNOF(FTwoVectors));
			UProperty* NewProp_v2 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("v2"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(v2, FTwoVectors), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_v1 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("v1"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(v1, FTwoVectors), 0x0010000001000005, Z_Construct_UScriptStruct_FVector());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_v2, TEXT("Category"), TEXT("TwoVectors"));
			MetaData->SetValue(NewProp_v2, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_v1, TEXT("Category"), TEXT("TwoVectors"));
			MetaData->SetValue(NewProp_v1, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTwoVectors_CRC() { return 3890693568U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVector2D()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FVector2D_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Vector2D"), sizeof(FVector2D), Get_Z_Construct_UScriptStruct_FVector2D_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Vector2D"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FVector2D), ALIGNOF(FVector2D));
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Y, FVector2D), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(X, FVector2D), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakVector2D"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeVector2D"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A point or direction FVector in 2d space.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Vector2D.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("Vector2D"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("Vector2D"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVector2D_CRC() { return 436359375U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVector4()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FVector4_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Vector4"), sizeof(FVector4), Get_Z_Construct_UScriptStruct_FVector4_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Vector4"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FVector4), ALIGNOF(FVector4));
			UProperty* NewProp_W = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("W"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(W, FVector4), 0x0010000001000005);
			UProperty* NewProp_Z = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Z"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Z, FVector4), 0x0010000001000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Y, FVector4), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(X, FVector4), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A 4-D homogeneous vector.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Vector4.h"));
			MetaData->SetValue(NewProp_W, TEXT("Category"), TEXT("Vector4"));
			MetaData->SetValue(NewProp_W, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Z, TEXT("Category"), TEXT("Vector4"));
			MetaData->SetValue(NewProp_Z, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("Vector4"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("Vector4"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVector4_CRC() { return 376452930U; }
	UScriptStruct* Z_Construct_UScriptStruct_FVector()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FVector_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Vector"), sizeof(FVector), Get_Z_Construct_UScriptStruct_FVector_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Vector"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FVector), ALIGNOF(FVector));
			UProperty* NewProp_Z = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Z"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Z, FVector), 0x0010000001000005);
			UProperty* NewProp_Y = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Y"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Y, FVector), 0x0010000001000005);
			UProperty* NewProp_X = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("X"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(X, FVector), 0x0010000001000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeBreak"), TEXT("Engine.KismetMathLibrary.BreakVector"));
			MetaData->SetValue(ReturnStruct, TEXT("HasNativeMake"), TEXT("Engine.KismetMathLibrary.MakeVector"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A point or direction FVector in 3d space.\nThe full C++ class is located here: Engine\\Source\\Runtime\\Core\\Public\\Math\\Vector.h"));
			MetaData->SetValue(NewProp_Z, TEXT("Category"), TEXT("Vector"));
			MetaData->SetValue(NewProp_Z, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_Y, TEXT("Category"), TEXT("Vector"));
			MetaData->SetValue(NewProp_Y, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_X, TEXT("Category"), TEXT("Vector"));
			MetaData->SetValue(NewProp_X, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FVector_CRC() { return 3670659668U; }
	UScriptStruct* Z_Construct_UScriptStruct_FGuid()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FGuid_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("Guid"), sizeof(FGuid), Get_Z_Construct_UScriptStruct_FGuid_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Guid"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000038), sizeof(FGuid), ALIGNOF(FGuid));
			UProperty* NewProp_D = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("D"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(D, FGuid), 0x0010000001000001);
			UProperty* NewProp_C = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("C"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(C, FGuid), 0x0010000001000001);
			UProperty* NewProp_B = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("B"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(B, FGuid), 0x0010000001000001);
			UProperty* NewProp_A = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("A"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(A, FGuid), 0x0010000001000001);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("A globally unique identifier."));
			MetaData->SetValue(NewProp_D, TEXT("Category"), TEXT("Guid"));
			MetaData->SetValue(NewProp_D, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_C, TEXT("Category"), TEXT("Guid"));
			MetaData->SetValue(NewProp_C, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_B, TEXT("Category"), TEXT("Guid"));
			MetaData->SetValue(NewProp_B, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(NewProp_A, TEXT("Category"), TEXT("Guid"));
			MetaData->SetValue(NewProp_A, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FGuid_CRC() { return 2934630346U; }
	UFunction* Z_Construct_UFunction_UObject_ExecuteUbergraph()
	{
		struct Object_eventExecuteUbergraph_Parms
		{
			int32 EntryPoint;
		};
		UObject* Outer=Z_Construct_UClass_UObject();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ExecuteUbergraph"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(Object_eventExecuteUbergraph_Parms));
			UProperty* NewProp_EntryPoint = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EntryPoint"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(EntryPoint, Object_eventExecuteUbergraph_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("BlueprintInternalUseOnly"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Executes some portion of the ubergraph.\n\n@param       EntryPoint      The entry point to start code execution at."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UObject_NoRegister()
	{
		return UObject::StaticClass();
	}
	UClass* Z_Construct_UClass_UObject()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UPackage__Script_CoreUObject();
			OuterClass = UObject::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000081;

				OuterClass->LinkChild(Z_Construct_UFunction_UObject_ExecuteUbergraph());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UObject_ExecuteUbergraph(), "ExecuteUbergraph"); // 2077348876
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("UObject/NoExportTypes.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/UObject/NoExportTypes.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	/* friend declarations for pasting into noexport class UObject
	friend COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	*/
	static FCompiledInDefer Z_CompiledInDefer_UClass_UObject(Z_Construct_UClass_UObject, &UObject::StaticClass, TEXT("UObject"), false, nullptr, nullptr, nullptr);
	UEnum* Z_Construct_UEnum_CoreUObject_ELifetimeCondition()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UEnum_CoreUObject_ELifetimeCondition_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("ELifetimeCondition"), 0, Get_Z_Construct_UEnum_CoreUObject_ELifetimeCondition_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ELifetimeCondition"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, int64>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_None")), 0));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_InitialOnly")), 1));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_OwnerOnly")), 2));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SkipOwner")), 3));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SimulatedOnly")), 4));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_AutonomousOnly")), 5));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SimulatedOrPhysics")), 6));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_InitialOrOwner")), 7));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_Custom")), 8));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_ReplayOrOwner")), 9));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_ReplayOnly")), 10));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SimulatedOnlyNoReplay")), 11));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SimulatedOrPhysicsNoReplay")), 12));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_SkipReplay")), 13));
			EnumNames.Add(TPairInitializer<FName, int64>(FName(TEXT("COND_Max")), 14));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("ELifetimeCondition");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_AutonomousOnly.DisplayName"), TEXT("Autonomous Only"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_AutonomousOnly.ToolTip"), TEXT("This property will only send to simulated actors"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_Custom.DisplayName"), TEXT("Custom"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_Custom.ToolTip"), TEXT("This property will send on the initial packet, or to the actors owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_InitialOnly.DisplayName"), TEXT("Initial Only"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_InitialOnly.ToolTip"), TEXT("This property has no condition, and will send anytime it changes"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_InitialOrOwner.DisplayName"), TEXT("Initial Or Owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_InitialOrOwner.ToolTip"), TEXT("This property will send to simulated OR bRepPhysics actors"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_Max.Hidden"), TEXT(""));
			MetaData->SetValue(ReturnEnum, TEXT("COND_Max.ToolTip"), TEXT("This property will not send to the replay connection"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_None.DisplayName"), TEXT("None"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_OwnerOnly.DisplayName"), TEXT("Owner Only"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_OwnerOnly.ToolTip"), TEXT("This property will only attempt to send on the initial bunch"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_ReplayOnly.DisplayName"), TEXT("Replay Only"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_ReplayOnly.ToolTip"), TEXT("This property will only send to the replay connection, or to the actors owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_ReplayOrOwner.DisplayName"), TEXT("Replay Or Owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_ReplayOrOwner.ToolTip"), TEXT("This property has no particular condition, but wants the ability to toggle on/off via SetCustomIsActiveOverride"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOnly.DisplayName"), TEXT("Simulated Only"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOnly.ToolTip"), TEXT("This property send to every connection EXCEPT the owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOnlyNoReplay.DisplayName"), TEXT("Simulated Only No Replay"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOnlyNoReplay.ToolTip"), TEXT("This property will only send to the replay connection"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOrPhysics.DisplayName"), TEXT("Simulated Or Physics"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOrPhysics.ToolTip"), TEXT("This property will only send to autonomous actors"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOrPhysicsNoReplay.DisplayName"), TEXT("Simulated Or Physics No Replay"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SimulatedOrPhysicsNoReplay.ToolTip"), TEXT("This property will send to actors only, but not to replay connections"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SkipOwner.DisplayName"), TEXT("Skip Owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SkipOwner.ToolTip"), TEXT("This property will only send to the actor's owner"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SkipReplay.DisplayName"), TEXT("Skip Replay"));
			MetaData->SetValue(ReturnEnum, TEXT("COND_SkipReplay.ToolTip"), TEXT("This property will send to simulated Or bRepPhysics actors, but not to replay connections"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreNetTypes.h"));
			MetaData->SetValue(ReturnEnum, TEXT("ToolTip"), TEXT("Secondary condition to check before considering the replication of a lifetime property."));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_CoreUObject_ELifetimeCondition_CRC() { return 3360802910U; }
	UScriptStruct* Z_Construct_UScriptStruct_FUniqueNetIdWrapper()
	{
		struct FUniqueNetIdWrapper
		{
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FUniqueNetIdWrapper_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("UniqueNetIdWrapper"), sizeof(FUniqueNetIdWrapper), Get_Z_Construct_UScriptStruct_FUniqueNetIdWrapper_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("UniqueNetIdWrapper"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FUniqueNetIdWrapper), ALIGNOF(FUniqueNetIdWrapper));
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FUniqueNetIdWrapper_CRC() { return 2175369229U; }
	UScriptStruct* Z_Construct_UScriptStruct_FJoinabilitySettings()
	{
		struct FJoinabilitySettings
		{
			FName SessionName;
			bool bPublicSearchable;
			bool bAllowInvites;
			bool bJoinViaPresence;
			bool bJoinViaPresenceFriendsOnly;
			int32 MaxPlayers;
			int32 MaxPartySize;
		};

		UPackage* Outer = Z_Construct_UPackage__Script_CoreUObject();
		extern uint32 Get_Z_Construct_UScriptStruct_FJoinabilitySettings_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("JoinabilitySettings"), sizeof(FJoinabilitySettings), Get_Z_Construct_UScriptStruct_FJoinabilitySettings_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("JoinabilitySettings"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, NULL, EStructFlags(0x00000008), sizeof(FJoinabilitySettings), ALIGNOF(FJoinabilitySettings));
			UProperty* NewProp_MaxPartySize = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxPartySize"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(MaxPartySize, FJoinabilitySettings), 0x0010000000000000);
			UProperty* NewProp_MaxPlayers = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("MaxPlayers"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(MaxPlayers, FJoinabilitySettings), 0x0010000000000000);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bJoinViaPresenceFriendsOnly, FJoinabilitySettings, bool);
			UProperty* NewProp_bJoinViaPresenceFriendsOnly = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bJoinViaPresenceFriendsOnly"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bJoinViaPresenceFriendsOnly, FJoinabilitySettings), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bJoinViaPresenceFriendsOnly, FJoinabilitySettings), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bJoinViaPresence, FJoinabilitySettings, bool);
			UProperty* NewProp_bJoinViaPresence = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bJoinViaPresence"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bJoinViaPresence, FJoinabilitySettings), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bJoinViaPresence, FJoinabilitySettings), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowInvites, FJoinabilitySettings, bool);
			UProperty* NewProp_bAllowInvites = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bAllowInvites"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowInvites, FJoinabilitySettings), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bAllowInvites, FJoinabilitySettings), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bPublicSearchable, FJoinabilitySettings, bool);
			UProperty* NewProp_bPublicSearchable = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("bPublicSearchable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bPublicSearchable, FJoinabilitySettings), 0x0010000000000000, CPP_BOOL_PROPERTY_BITMASK(bPublicSearchable, FJoinabilitySettings), sizeof(bool), true);
			UProperty* NewProp_SessionName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("SessionName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(SessionName, FJoinabilitySettings), 0x0010000000000000);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Circular dependency on Core vs UHT means we have to noexport these structs so tools can build"));
			MetaData->SetValue(NewProp_MaxPartySize, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_MaxPartySize, TEXT("ToolTip"), TEXT("Current max party size in this session"));
			MetaData->SetValue(NewProp_MaxPlayers, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_MaxPlayers, TEXT("ToolTip"), TEXT("Current max players in this session"));
			MetaData->SetValue(NewProp_bJoinViaPresenceFriendsOnly, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_bJoinViaPresenceFriendsOnly, TEXT("ToolTip"), TEXT("Does this session allow friends to join via presence"));
			MetaData->SetValue(NewProp_bJoinViaPresence, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_bJoinViaPresence, TEXT("ToolTip"), TEXT("Does this session allow public join via presence"));
			MetaData->SetValue(NewProp_bAllowInvites, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_bAllowInvites, TEXT("ToolTip"), TEXT("Does this session allow invites"));
			MetaData->SetValue(NewProp_bPublicSearchable, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_bPublicSearchable, TEXT("ToolTip"), TEXT("Is this session now publicly searchable"));
			MetaData->SetValue(NewProp_SessionName, TEXT("ModuleRelativePath"), TEXT("Public/UObject/CoreOnline.h"));
			MetaData->SetValue(NewProp_SessionName, TEXT("ToolTip"), TEXT("Name of session these settings affect"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FJoinabilitySettings_CRC() { return 2026123428U; }
	UPackage* Z_Construct_UPackage__Script_CoreUObject()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/CoreUObject")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x216A063C;
			Guid.B = 0x1C6D9490;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

			Z_Construct_UScriptStruct_FJoinabilitySettings();
			Z_Construct_UScriptStruct_FUniqueNetIdWrapper();
			Z_Construct_UScriptStruct_FGuid();
			Z_Construct_UScriptStruct_FVector();
			Z_Construct_UScriptStruct_FVector4();
			Z_Construct_UScriptStruct_FVector2D();
			Z_Construct_UScriptStruct_FTwoVectors();
			Z_Construct_UScriptStruct_FPlane();
			Z_Construct_UScriptStruct_FRotator();
			Z_Construct_UScriptStruct_FQuat();
			Z_Construct_UScriptStruct_FPackedNormal();
			Z_Construct_UScriptStruct_FPackedRGB10A2N();
			Z_Construct_UScriptStruct_FPackedRGBA16N();
			Z_Construct_UScriptStruct_FIntPoint();
			Z_Construct_UScriptStruct_FIntVector();
			Z_Construct_UScriptStruct_FColor();
			Z_Construct_UScriptStruct_FLinearColor();
			Z_Construct_UScriptStruct_FBox();
			Z_Construct_UScriptStruct_FBox2D();
			Z_Construct_UScriptStruct_FBoxSphereBounds();
			Z_Construct_UScriptStruct_FOrientedBox();
			Z_Construct_UScriptStruct_FMatrix();
			Z_Construct_UScriptStruct_FInterpCurvePointFloat();
			Z_Construct_UScriptStruct_FInterpCurveFloat();
			Z_Construct_UScriptStruct_FInterpCurvePointVector2D();
			Z_Construct_UScriptStruct_FInterpCurveVector2D();
			Z_Construct_UScriptStruct_FInterpCurvePointVector();
			Z_Construct_UScriptStruct_FInterpCurveVector();
			Z_Construct_UScriptStruct_FInterpCurvePointQuat();
			Z_Construct_UScriptStruct_FInterpCurveQuat();
			Z_Construct_UScriptStruct_FInterpCurvePointTwoVectors();
			Z_Construct_UScriptStruct_FInterpCurveTwoVectors();
			Z_Construct_UScriptStruct_FInterpCurvePointLinearColor();
			Z_Construct_UScriptStruct_FInterpCurveLinearColor();
			Z_Construct_UScriptStruct_FTransform();
			Z_Construct_UScriptStruct_FRandomStream();
			Z_Construct_UScriptStruct_FDateTime();
			Z_Construct_UScriptStruct_FTimespan();
			Z_Construct_UScriptStruct_FStringAssetReference();
			Z_Construct_UScriptStruct_FStringClassReference();
			Z_Construct_UScriptStruct_FFallbackStruct();
			Z_Construct_UScriptStruct_FFloatRangeBound();
			Z_Construct_UScriptStruct_FFloatRange();
			Z_Construct_UScriptStruct_FInt32RangeBound();
			Z_Construct_UScriptStruct_FInt32Range();
			Z_Construct_UScriptStruct_FFloatInterval();
			Z_Construct_UScriptStruct_FInt32Interval();
		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
